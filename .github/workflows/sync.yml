name: CloudStream Transfer (Debug Mode)

on:
  workflow_dispatch:
  schedule:
    - cron: '*/30 * * * *'

jobs:
  sync_service:
    runs-on: ubuntu-latest
    timeout-minutes: 350

    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Setup Env
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Tools
      run: |
        pip install psycopg2-binary huggingface_hub requests
        sudo apt-get update && sudo apt-get install -y ffmpeg

    - name: Stream Process
      id: transfer
      env:
        DB_CONNECT: ${{ secrets.DB_CONNECT }}
        HF_TOKEN: ${{ secrets.HF_TOKEN }}
        HF_REPO_ID: ${{ secrets.HF_REPO_ID }}
      run: |
        python <<EOF
        import os
        import psycopg2
        import subprocess
        import shutil
        import time
        import threading
        from huggingface_hub import HfApi
        from urllib.parse import unquote

        # === é…ç½® ===
        TABLE = "sys_logs"
        COL_URL = "payload"
        COL_STATUS = "level"
        COL_FOLDER = "folder"
        ST_PENDING = "info"
        ST_PROCESS = "warn"
        ST_DONE = "debug"
        # ==========

        db_url = os.environ.get("DB_CONNECT")
        hf_token = os.environ.get("HF_TOKEN")
        repo_id = os.environ.get("HF_REPO_ID")
        api = HfApi(token=hf_token)

        slice_dir = ""
        target_hf_path = ""
        is_ffmpeg_running = False
        uploaded_files = set()

        def upload_monitor():
            print("ğŸ‘€ [Monitor] ä¸Šä¼ çº¿ç¨‹å°±ç»ª...")
            while is_ffmpeg_running or (os.path.exists(slice_dir) and len(os.listdir(slice_dir)) > 0):
                try:
                    if not os.path.exists(slice_dir): break
                    files = sorted([f for f in os.listdir(slice_dir) if f.endswith('.ts') or f.endswith('.m3u8')])
                except:
                    break
                
                for f in files:
                    local_path = os.path.join(slice_dir, f)
                    should_upload = False
                    if f.endswith('.ts'):
                        if not is_ffmpeg_running: should_upload = True 
                        elif f != files[-1]: should_upload = True
                    elif f.endswith('.m3u8') and not is_ffmpeg_running:
                        should_upload = True

                    if should_upload:
                        if f not in uploaded_files:
                            try:
                                api.upload_file(
                                    path_or_fileobj=local_path,
                                    path_in_repo=f"{target_hf_path}/{f}",
                                    repo_id=repo_id,
                                    repo_type="dataset"
                                )
                                uploaded_files.add(f)
                                os.remove(local_path)
                            except Exception as e:
                                print(f"âš ï¸ [Upload Error] {f}: {e}")
                time.sleep(2)

        print("ğŸš€ [Debug] å¼€å§‹æ£€æŸ¥ä»»åŠ¡...")
        try:
            conn = psycopg2.connect(db_url)
            cur = conn.cursor()

            cur.execute(f'SELECT id, {COL_URL}, {COL_FOLDER} FROM "{TABLE}" WHERE "{COL_STATUS}" = %s LIMIT 1', (ST_PENDING,))
            row = cur.fetchone()
            
            if row:
                task_id, file_url, folder_name = row
                
                if not folder_name or folder_name.strip() == "": folder_name = "Downloads"
                folder_name = folder_name.strip().replace("..", "").strip("/")

                print(f"âœ… ä»»åŠ¡ID: {task_id} | é“¾æ¥: {file_url[:50]}...")
                
                cur.execute(f'UPDATE "{TABLE}" SET "{COL_STATUS}" = %s WHERE id = %s', (ST_PROCESS, task_id))
                conn.commit()
                
                try:
                    raw_filename = unquote(file_url.split('/')[-1].split('?')[0])
                    base_name = os.path.splitext(raw_filename)[0]
                    if len(base_name) > 100: base_name = f"video_{task_id}"
                except:
                    base_name = f"video_{task_id}"
                
                slice_dir = f"slice_{task_id}"
                target_hf_path = f"{folder_name}/{base_name}"
                
                if os.path.exists(slice_dir): shutil.rmtree(slice_dir)
                os.makedirs(slice_dir)
                
                print(f"ğŸ¬ å¼€å§‹ FFmpeg å¤„ç†: {base_name}")

                m3u8_file = os.path.join(slice_dir, "index.m3u8")
                ts_format = os.path.join(slice_dir, "%04d.ts")
                
                # ä¼ªè£… User-Agent (è¿™æ˜¯æœ€å…³é”®çš„)
                user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                
                cmd = [
                    "ffmpeg", 
                    "-user_agent", user_agent,
                    "-headers", f"User-Agent: {user_agent}",
                    "-i", file_url,
                    "-c", "copy",
                    "-hls_time", "5",
                    "-hls_playlist_type", "vod",
                    "-hls_segment_filename", ts_format,
                    "-hls_list_size", "0",
                    "-f", "hls",
                    m3u8_file
                ]
                
                is_ffmpeg_running = True
                uploader = threading.Thread(target=upload_monitor)
                uploader.start()
                
                # ğŸ”¥ã€ä¿®æ”¹ç‚¹ã€‘å¼€å¯æ—¥å¿—è¾“å‡ºï¼Œæ–¹ä¾¿æ’æŸ¥é”™è¯¯
                result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                
                is_ffmpeg_running = False
                uploader.join()
                
                if result.returncode == 0:
                    print("ğŸ‰ æˆåŠŸ!")
                    cur.execute(f'UPDATE "{TABLE}" SET "{COL_STATUS}" = %s WHERE id = %s', (ST_DONE, task_id))
                    conn.commit()
                    
                    with open(os.environ['GITHUB_ENV'], 'a') as f:
                        f.write(f"SYNC_FILENAME={base_name}\n")
                        f.write(f"SYNC_FOLDER={folder_name}\n")
                        play_url = f"https://huggingface.co/datasets/{repo_id}/resolve/main/{target_hf_path}/index.m3u8"
                        f.write(f"PLAY_URL={play_url}\n")
                        
                    if os.path.exists(slice_dir): shutil.rmtree(slice_dir)

                else:
                    # ğŸ”¥ã€å…³é”®ã€‘æ‰“å°è¯¦ç»†æŠ¥é”™æ—¥å¿—
                    print("\n========== FFmpeg æŠ¥é”™æ—¥å¿— ==========")
                    print(result.stdout.decode('utf-8', errors='ignore')[-2000:]) # åªæ‰“å°æœ€å2000å­—ç¬¦
                    print("=====================================\n")
                    
                    cur.execute(f'UPDATE "{TABLE}" SET "{COL_STATUS}" = %s WHERE id = %s', ('fatal', task_id))
                    conn.commit()
                    if os.path.exists(slice_dir): shutil.rmtree(slice_dir)
                    exit(1)
            else:
                print("ğŸ’¤ æ— æ–°ä»»åŠ¡")
            
            cur.close()
            conn.close()

        except Exception as e:
            print(f"âŒ è„šæœ¬é”™è¯¯: {e}")
            exit(1)
        EOF

    - name: Notify Success
      if: success() && env.SYNC_FILENAME != ''
      uses: dawidd6/action-send-mail@v3
      with:
        server_address: smtp.qq.com
        server_port: 465
        username: ${{ secrets.MAIL_USERNAME }}
        password: ${{ secrets.MAIL_PASSWORD }}
        subject: ğŸ¬ [å®Œæˆ] ${{ env.SYNC_FILENAME }}
        body: |
          æ–‡ä»¶å½’æ¡£æˆåŠŸ (HLSåˆ‡ç‰‡)ã€‚
          ğŸ“‚ ç›®å½•: ${{ env.SYNC_FOLDER }}
          â–¶ï¸ æ’­æ”¾é“¾æ¥: ${{ env.PLAY_URL }}
        to: ${{ secrets.MAIL_USERNAME }}
        from: CloudStream Bot
        secure: true
